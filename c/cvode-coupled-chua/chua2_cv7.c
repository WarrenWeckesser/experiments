/*
 *  chua2_cv7.c
 *
 *  CVODE C file for the vector field named: chua2
 *
 *  This file was generated by the program VFGEN, version: 2.6.0.dev5
 *  Generated on 22-Sep-2024 at 16:56
 */

#include <math.h>

#include <cvode/cvode.h>
#include <nvector/nvector_serial.h>
#include <sunmatrix/sunmatrix_dense.h> /* dense SUNMatrix       */

/*
 *  The vector field.
 */

int chua2_vf(sunrealtype t, N_Vector y_, N_Vector f_, void *params)
{
    (void) t;  /* Hack to avoid 'unused parameter' compiler warnings. */
    sunrealtype x, y, z, xp, yp, zp;
    sunrealtype alpha, beta, a, b, delta_x, delta_y, delta_z, Q, Qp;
    sunrealtype f, fp;
    sunrealtype *p_;

    p_ = (sunrealtype *) params;

    x  = NV_Ith_S(y_,0);
    y  = NV_Ith_S(y_,1);
    z  = NV_Ith_S(y_,2);
    xp = NV_Ith_S(y_,3);
    yp = NV_Ith_S(y_,4);
    zp = NV_Ith_S(y_,5);

    alpha   = p_[0];
    beta    = p_[1];
    a       = p_[2];
    b       = p_[3];
    delta_x = p_[4];
    delta_y = p_[5];
    delta_z = p_[6];
    Q       = p_[7];
    Qp      = p_[8];

    f =  x*b*(Q*Q)-x*( (Q*Q)-1.0)*a-( b-a)*Q;
    fp = -( b-a)*Qp+(Qp*Qp)*b*xp-a*( (Qp*Qp)-1.0)*xp;

    NV_Ith_S(f_,0) = -delta_x*( x-xp)-alpha*( f-y+x);
    NV_Ith_S(f_,1) = -y+x-delta_y*( y-yp)+z;
    NV_Ith_S(f_,2) = -beta*y+delta_z*( zp-z);
    NV_Ith_S(f_,3) =  delta_x*( x-xp)-alpha*( fp-yp+xp);
    NV_Ith_S(f_,4) =  delta_y*( y-yp)+zp-yp+xp;
    NV_Ith_S(f_,5) = -delta_z*( zp-z)-beta*yp;
    return 0;
}

/*
 *  The Jacobian.
 */

int chua2_jac(sunrealtype t, N_Vector y_, N_Vector fy_, SUNMatrix jac_, void *params,
                N_Vector tmp1, N_Vector tmp2, N_Vector tmp3)
{
    (void) t;     /* Hack to avoid 'unused parameter' compiler warnings. */
    (void) fy_;   /* Hack to avoid 'unused parameter' compiler warnings. */
    (void) tmp1;  /* Hack to avoid 'unused parameter' compiler warnings. */
    (void) tmp2;  /* Hack to avoid 'unused parameter' compiler warnings. */
    (void) tmp3;  /* Hack to avoid 'unused parameter' compiler warnings. */
    sunrealtype x, y, z, xp, yp, zp;
    sunrealtype alpha, beta, a, b, delta_x, delta_y, delta_z, Q, Qp;
    sunrealtype *p_;

    p_ = (sunrealtype *) params;

    x  = NV_Ith_S(y_, 0);
    y  = NV_Ith_S(y_, 1);
    z  = NV_Ith_S(y_, 2);
    xp = NV_Ith_S(y_, 3);
    yp = NV_Ith_S(y_, 4);
    zp = NV_Ith_S(y_, 5);

    alpha   = p_[0];
    beta    = p_[1];
    a       = p_[2];
    b       = p_[3];
    delta_x = p_[4];
    delta_y = p_[5];
    delta_z = p_[6];
    Q       = p_[7];
    Qp      = p_[8];

    SM_ELEMENT_D(jac_, 0, 0) =  alpha*( ( (Q*Q)-1.0)*a-b*(Q*Q)-1.0)-delta_x;
    SM_ELEMENT_D(jac_, 0, 1) = alpha;
    SM_ELEMENT_D(jac_, 0, 3) = delta_x;
    SM_ELEMENT_D(jac_, 1, 0) = 1.0;
    SM_ELEMENT_D(jac_, 1, 1) = -delta_y-1.0;
    SM_ELEMENT_D(jac_, 1, 2) = 1.0;
    SM_ELEMENT_D(jac_, 1, 4) = delta_y;
    SM_ELEMENT_D(jac_, 2, 1) = -beta;
    SM_ELEMENT_D(jac_, 2, 2) = -delta_z;
    SM_ELEMENT_D(jac_, 2, 5) = delta_z;
    SM_ELEMENT_D(jac_, 3, 0) = delta_x;
    SM_ELEMENT_D(jac_, 3, 3) = -delta_x+alpha*( a*( (Qp*Qp)-1.0)-(Qp*Qp)*b-1.0);
    SM_ELEMENT_D(jac_, 3, 4) = alpha;
    SM_ELEMENT_D(jac_, 4, 1) = delta_y;
    SM_ELEMENT_D(jac_, 4, 3) = 1.0;
    SM_ELEMENT_D(jac_, 4, 4) = -delta_y-1.0;
    SM_ELEMENT_D(jac_, 4, 5) = 1.0;
    SM_ELEMENT_D(jac_, 5, 2) = delta_z;
    SM_ELEMENT_D(jac_, 5, 4) = -beta;
    SM_ELEMENT_D(jac_, 5, 5) = -delta_z;
    return 0;
}

/*
 *  User-defined functions. 
 */

int chua2_func(sunrealtype t, N_Vector y_, sunrealtype *func_, void *params)
{
    (void) t;  /* Hack to avoid 'unused parameter' compiler warnings. */
    sunrealtype x, y, z, xp, yp, zp;
    sunrealtype alpha, beta, a, b, delta_x, delta_y, delta_z, Q, Qp;
    sunrealtype f, fp;
    sunrealtype *p_;

    p_ = (sunrealtype *) params;

    x  = NV_Ith_S(y_,0);
    y  = NV_Ith_S(y_,1);
    z  = NV_Ith_S(y_,2);
    xp = NV_Ith_S(y_,3);
    yp = NV_Ith_S(y_,4);
    zp = NV_Ith_S(y_,5);

    alpha   = p_[0];
    beta    = p_[1];
    a       = p_[2];
    b       = p_[3];
    delta_x = p_[4];
    delta_y = p_[5];
    delta_z = p_[6];
    Q       = p_[7];
    Qp      = p_[8];

    f =  x*b*(Q*Q)-x*( (Q*Q)-1.0)*a-( b-a)*Q;
    fp = -( b-a)*Qp+(Qp*Qp)*b*xp-a*( (Qp*Qp)-1.0)*xp;

    /* x_equals_neg1:  */
    func_[0] =  x+1.0;
    /* x_equals_pos1:  */
    func_[1] =  x-1.0;
    /* xp_equals_neg1:  */
    func_[2] =  xp+1.0;
    /* xp_equals_pos1:  */
    func_[3] =  xp-1.0;
    return 0;
}
